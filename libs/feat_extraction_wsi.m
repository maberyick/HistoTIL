function feat_extraction_wsi(folder_matpatches,folder_pyepistroma,folder_matcellmask,folder_savepath,quality,folder_type)
lympModel=load(['./libs/lymp_svm_matlab_wsi.mat']);
lympModel = lympModel.model;
placeholder = 'placeholder';
% determine if single tiles (case) or folder (multiple cases)
if folder_type == "tile_type"
    imgList=dir([folder_matpatches '*.png']);
    indx = randperm(numel(imgList));
    numFiles=length(imgList);
    imgList = {imgList(:).name};
    imgList = parallel.pool.Constant(imgList);
    qualitysaturationLim = quality.saturationLim;
    qualityredChannelLim = quality.redChannelLim;
    qualityblurLimit = quality.blurLimit;
    qualityimgarea = quality.imgarea;
    parfor nn=1:numFiles
        i= indx(nn);
        [~,imgName]=fileparts(imgList.Value{i});
        outputFolder=[folder_savepath 'dataset_output/' imgName];
        maskFolder=[outputFolder '/png_binmask/png_cellmask/'];
        maskEFolder=[outputFolder '/png_binmask/png_cellepimask/'];
        maskSFolder=[outputFolder '/png_binmask/png_cellstromask/'];
        maskBFolder=[outputFolder '/png_binmask/png_cellbundmask/'];
        ESmaskFolder=[outputFolder '/png_binmask/png_epithmask/'];
        SSmaskFolder=[outputFolder '/png_binmask/png_stromask/'];
        EBmaskFolder=[outputFolder '/png_binmask/png_boundaryepistromask/'];
        featlocFolder=[outputFolder '/TIL_features/'];
        disp(outputFolder)
        [~,~] = mkdir(outputFolder);
        [~,~] = mkdir(maskFolder);
        [~,~] = mkdir(maskEFolder);
        [~,~] = mkdir(maskSFolder);
        [~,~] = mkdir(maskBFolder);
        [~,~] = mkdir(ESmaskFolder);
        [~,~] = mkdir(SSmaskFolder);
        [~,~] = mkdir(EBmaskFolder);
        [~,~] = mkdir(featlocFolder);
        featFile=sprintf('%s/%s.mat',featlocFolder,imgName);
        maskFile=sprintf('%s/%s.png',maskFolder,imgName);
        maskEFile=sprintf('%s/%s.png',maskEFolder,imgName);
        maskSFile=sprintf('%s/%s.png',maskSFolder,imgName);
        maskBFile=sprintf('%s/%s.png',maskBFolder,imgName);
        ESmaskFile=sprintf('%s/%s.png',ESmaskFolder,imgName);
        SSmaskFile=sprintf('%s/%s.png',SSmaskFolder,imgName);
        EBmaskFile=sprintf('%s/%s.png',EBmaskFolder,imgName);
        % load the image
        curTile = imread([folder_matpatches imgList.Value{i}]);
        [ima,imb,~] = size(curTile);
        % load the epistroma mask
        curTile_ESmask = imread([folder_pyepistroma imgList.Value{i}]);
        [ms1a,~,~] = size(curTile_ESmask);  
        % load the nuclei mask, if not saved, calculate
        curTile_Nmask = imread([folder_matcellmask imgList.Value{i}]);
        [ms2a,~,~] = size(curTile_Nmask);  
        % check for size
        if ima ~= ms1a
            curTile_ESmask = imresize(curTile_ESmask,[ima imb]);
        end
        if ima ~= ms2a
            curTile_Nmask = imresize(curTile_Nmask,[ima imb]);
        end
        % get_cleanMask_v2
        %get_cleanMask_v2(I,M,maskFile);

        % generate the nuclei mask
        if (getSaturationMetric(curTile)>qualitysaturationLim && ...
                getRedMetric(curTile)>qualityredChannelLim && ...
                blurMetric(curTile)>qualityblurLimit && ...
                getAreaTissue(curTile)>qualityimgarea)
            if exist(featFile,'file')~=2
                parsave(featFile, placeholder);
                % Check if Cell mask and Epistroma mask have same quantity
                if size(curTile_ESmask) == size(curTile_Nmask)
                    fprintf('Processing tile %s_%d\n',imgName,i);
                    [nucleiCentroids,isLymphocyte,nucFeatures,denFeat,spaFeat,ctxFeat,nucleiCentroids_stro,...
                        isLymphocyte_stro,nucFeatures_stro,denFeat_stro,spaFeat_stro,ctxFeat_stro,nucleiCentroids_epi,isLymphocyte_epi,...
                        nucFeatures_epi,denFeat_epi,spaFeat_epi,ctxFeat_epi,nucleiCentroids_bund,isLymphocyte_bund,nucFeatures_bund,...
                        denFeat_bund,spaFeat_bund,ctxFeat_bund] = get_mixTIL(...
                        curTile,curTile_ESmask,curTile_Nmask,maskFile,maskEFile,...
                        maskSFile,maskBFile,ESmaskFile,SSmaskFile,EBmaskFile,lympModel);
                    parsave_cellfeat_mixtil(featFile,nucleiCentroids,isLymphocyte,nucFeatures,denFeat,spaFeat,ctxFeat,nucleiCentroids_stro,...
                        isLymphocyte_stro,nucFeatures_stro,denFeat_stro,spaFeat_stro,ctxFeat_stro,nucleiCentroids_epi,isLymphocyte_epi,...
                        nucFeatures_epi,denFeat_epi,spaFeat_epi,ctxFeat_epi,nucleiCentroids_bund,isLymphocyte_bund,nucFeatures_bund,...
                        denFeat_bund,spaFeat_bund,ctxFeat_bund);
                else
                    filePh_error = fopen([folder_savepath 'errorlist_patches.txt'],'a');
                    fprintf(filePh_error,'Mismatch cell and epistroma mask %s_%d\n',imgName,indx2(i));
                    fclose(filePh_error);
                    continue
                end
            else
                disp('mat tile already exists')
                continue
            end
        end
    end
elseif folder_type == "folder_type"
    folderList = dir(folder_matpatches);
    folderNames = {folderList([folderList.isdir]).name};
    folderNames = folderNames(~ismember(folderNames ,{'.','..'}));
    for mm=1:length(folderNames)
        folderName = folderNames{mm};
        imgList=dir([folder_matpatches folderName filesep '*.png']);
        indx = randperm(numel(imgList));
        numFiles=length(imgList);
        imgList = {imgList(:).name};
        imgList = parallel.pool.Constant(imgList);
        qualitysaturationLim = quality.saturationLim;
        qualityredChannelLim = quality.redChannelLim;
        qualityblurLimit = quality.blurLimit;
        qualityimgarea = quality.imgarea;
        parfor nn=1:numFiles
            i= indx(nn);
            [~,imgName]=fileparts(imgList.Value{i});
            outputFolder=[folder_savepath 'dataset_output' filesep folderName];
            maskFolder=[outputFolder filesep 'png_binmask' filesep 'png_cellmask'];
            maskEFolder=[outputFolder filesep 'png_binmask' filesep 'png_cellepimask'];
            maskSFolder=[outputFolder filesep 'png_binmask' filesep 'png_cellstromask'];
            maskBFolder=[outputFolder filesep 'png_binmask' filesep 'png_cellbundmask'];
            ESmaskFolder=[outputFolder filesep 'png_binmask' filesep 'png_epithmask'];
            SSmaskFolder=[outputFolder filesep 'png_binmask' filesep 'png_stromask'];
            EBmaskFolder=[outputFolder filesep 'png_binmask' filesep 'png_boundaryepistromask'];
            featlocFolder=[outputFolder filesep 'TIL_features'];
            disp(outputFolder)
            [~,~] = mkdir(outputFolder);
            [~,~] = mkdir(maskFolder);
            [~,~] = mkdir(maskEFolder);
            [~,~] = mkdir(maskSFolder);
            [~,~] = mkdir(maskBFolder);
            [~,~] = mkdir(ESmaskFolder);
            [~,~] = mkdir(SSmaskFolder);
            [~,~] = mkdir(EBmaskFolder);
            [~,~] = mkdir(featlocFolder);
            featFile=sprintf('%s/%s.mat',featlocFolder,imgName);
            maskFile=sprintf('%s/%s.png',maskFolder,imgName);
            maskEFile=sprintf('%s/%s.png',maskEFolder,imgName);
            maskSFile=sprintf('%s/%s.png',maskSFolder,imgName);
            maskBFile=sprintf('%s/%s.png',maskBFolder,imgName);
            ESmaskFile=sprintf('%s/%s.png',ESmaskFolder,imgName);
            SSmaskFile=sprintf('%s/%s.png',SSmaskFolder,imgName);
            EBmaskFile=sprintf('%s/%s.png',EBmaskFolder,imgName);
            % load the image
            curTile = imread([folder_matpatches folderName filesep imgList.Value{i}]);
            [ima,imb,~] = size(curTile);
            % load the epistroma mask
            curTile_ESmask = imread([folder_pyepistroma folderName filesep imgList.Value{i}]);
            [ms1a,~,~] = size(curTile_ESmask);
            % load the nuclei mask, if not saved, calculate
            curTile_Nmask = imread([folder_matcellmask folderName filesep imgList.Value{i}]);
            [ms2a,~,~] = size(curTile_Nmask);
            % check for size
            if ima ~= ms1a
                curTile_ESmask = imresize(curTile_ESmask,[ima imb]);
            end
            if ima ~= ms2a
                curTile_Nmask = imresize(curTile_Nmask,[ima imb]);
            end
            % get_cleanMask_v2
            %get_cleanMask_v2(I,M,maskFile);

            % generate the nuclei mask
            if (getSaturationMetric(curTile)>qualitysaturationLim && ...
                    getRedMetric(curTile)>qualityredChannelLim && ...
                    blurMetric(curTile)>qualityblurLimit && ...
                    getAreaTissue(curTile)>qualityimgarea)
                if exist(featFile,'file')~=2
                    parsave(featFile, placeholder);
                    % Check if Cell mask and Epistroma mask have same quantity
                    %                     if size(curTile_ESmask) == size(curTile_Nmask)
                    fprintf('Processing tile %s_%d\n',imgName,i);
                    [nucleiCentroids,isLymphocyte,nucFeatures,denFeat,spaFeat,ctxFeat,nucleiCentroids_stro,...
                        isLymphocyte_stro,nucFeatures_stro,denFeat_stro,spaFeat_stro,ctxFeat_stro,nucleiCentroids_epi,isLymphocyte_epi,...
                        nucFeatures_epi,denFeat_epi,spaFeat_epi,ctxFeat_epi,nucleiCentroids_bund,isLymphocyte_bund,nucFeatures_bund,...
                        denFeat_bund,spaFeat_bund,ctxFeat_bund] = get_mixTIL(...
                        curTile,curTile_ESmask,curTile_Nmask,maskFile,maskEFile,...
                        maskSFile,maskBFile,ESmaskFile,SSmaskFile,EBmaskFile,lympModel);
                    parsave_cellfeat_mixtil(featFile,nucleiCentroids,isLymphocyte,nucFeatures,denFeat,spaFeat,ctxFeat,nucleiCentroids_stro,...
                        isLymphocyte_stro,nucFeatures_stro,denFeat_stro,spaFeat_stro,ctxFeat_stro,nucleiCentroids_epi,isLymphocyte_epi,...
                        nucFeatures_epi,denFeat_epi,spaFeat_epi,ctxFeat_epi,nucleiCentroids_bund,isLymphocyte_bund,nucFeatures_bund,...
                        denFeat_bund,spaFeat_bund,ctxFeat_bund);
                    %                     else
                    %                         filePh_error = fopen([folder_savepath 'errorlist_patches.txt'],'a');
                    %                         fprintf(filePh_error,'Mismatch cell and epistroma mask %s_%d\n',imgName,indx2(i));
                    %                         fclose(filePh_error);
                    %                         continue
                    %                     end
                else
                    disp('mat tile already exists')
                    continue
                end
            end
        end
    end
else
    disp('no fodler type')
end
%ToDo: include method to delete the 1Kb files
% parfor n=1:numFiles
%     [~,imgName]=fileparts(imgList.Value{n});
%     % ToDo: Check if the nuclei and ES are already being processed, to be
%     % used with another feature set
%     %imgFile=[folder_matpatches imgList{n}];
%     outputFolder=[folder_savepath 'dataset_output/' imgName];
%     featlocFolder=[outputFolder '/TIL_features/*.mat'];
%     files = dir(featlocFolder);
%     for ii = 1:length(files)
%         if files(ii).bytes==187 % file with 'placeholder' word
%             delete(fullfile(files(ii).folder, files(ii).name))
%         end
%     end
% end
fprintf('Done!\n');
% Save the geenral feature description
 description_spaTIL = {'avg of ratio of the nuceli cluster density to its closest lym cluster cluster',...
    'avg of ratio of the nuceli cluster density to its second closest lym cluster density',...
    'avg of ratio of the nuceli cluster density to its third closest lym cluster density',...
    'avg of ratio of the nuceli cluster density to its first three closest lym cluster mean density',...
    'std of ratio of the nuceli cluster density to its closest lym cluster cluster',...
    'std of ratio of the nuceli cluster density to its second closest lym cluster density',...
    'std of ratio of the nuceli cluster density to its third closest lym cluster density',...
    'std of ratio of the nuceli cluster density to its first three closest lym cluster mean density',...
    'var of ratio of the nuceli cluster density to its closest lym cluster cluster',...
    'var of ratio of the nuceli cluster density to its second closest lym cluster density',...
    'var of ratio of the nuceli cluster density to its third closest lym cluster density',...
    'var of ratio of the nuceli cluster density to its first three closest lym cluster mean density',...
    'min of ratio of the nuceli cluster density to its closest lym cluster cluster',...
    'min of ratio of the nuceli cluster density to its second closest lym cluster density',...
    'min of ratio of the nuceli cluster density to its third closest lym cluster density',...
    'min of ratio of the nuceli cluster density to its first three closest lym cluster mean density',...
    'max of ratio of the nuceli cluster density to its closest lym cluster cluster',...
    'max of ratio of the nuceli cluster density to its second closest lym cluster density',...
    'max of ratio of the nuceli cluster density to its third closest lym cluster density',...
    'max of ratio of the nuceli cluster density to its first three closest lym cluster mean density',...
    'range of ratio of the nuceli cluster density to its closest lym cluster cluster',...
    'range of ratio of the nuceli cluster density to its second closest lym cluster density',...
    'range of ratio of the nuceli cluster density to its third closest lym cluster density',...
    'range of ratio of the nuceli cluster density to its first three closest lym cluster mean density',...
    'avg of reciprocal of number of least lym cluster to encompass nuclei cluster'...
    'std of reciprocal of number of least lym cluster to encompass nuclei cluster'...
    'var of reciprocal of number of least lym cluster to encompass nuclei cluster'...
    'min of reciprocal of number of least lym cluster to encompass nuclei cluster'...
    'max of reciprocal of number of least lym cluster to encompass nuclei cluster'...
    'range of reciprocal of number of least lym cluster to encompass nuclei cluster',...
    'avg of area ratio of nuclei cluster to encompassed lym clusters'...
    'std of area ratio of nuclei cluster to encompassed lym clusters'...
    'var of area ratio of nuclei cluster to encompassed lym clusters'...
    'min of area ratio of nuclei cluster to encompassed lym clusters'...
    'max of area ratio of nuclei cluster to encompassed lym clusters'...
    'range of area ratio of nuclei cluster to encompassed lym clusters'...
    'avg of density ratio of nuclei cluster to encompassed lym clusters'...
    'std of density ratio of nuclei cluster to encompassed lym clusters'...
    'var of density ratio of nuclei cluster to encompassed lym clusters'...
    'min of density ratio of nuclei cluster to encompassed lym clusters'...
    'max of density ratio of nuclei cluster to encompassed lym clusters'...
    'range of density ratio of nuclei cluster to encompassed lym clusters',...
    '1-norm of the vector by ratio of nucleiDegree to LymDegree'...
    '1-norm of the vector by ratio of nucleiCloseness to LymCloseness'...
    '1-norm of the vector by nucleiBetweenness minus LymBetweenness'...
    '1-norm of the vector by ratio of nucleiEigenvector to LymEigenvector'...
    '1-norm of the vector by ratio of nucleiSumIndex to LymSumIndex'...
    'ratio of number of unique lym nodes to all lym nodes'...
    'average distance of nuclei to nearest lym',...
    'lympTotArea','lymAvgArea','lymMedianArea','lymStdArea',...
    'lymModeArea','nonLympTotArea','nonLymAvgArea','nonLymMedianArea',...
    'nonLymStdArea','nonLymModeArea',...
    'lympTotDensity','lymAvgDensity','lymMedianDensity',...
    'lymStdDensity','lymModeDensity','nonLympTotDensity','nonLymAvgDensity',...
    'nonLymMedianDensity','nonLymStdDensity','nonLymModeDensity',...
    'intersectedArea',...
    'avg_1_nearest','median_1_nearest','mode_1_nearest',...
    'avg_2_nearest','median_2_nearest','mode_2_nearest',...
    'avg_3_nearest','median_1_nearest','mode_3_nearest',...
    'avg_4_nearest','median_1_nearest','mode_4_nearest',...
    'avg_5_nearest','median_1_nearest','mode_5_nearest'};
zernFeats=zeros(1,36*2);
numZernikePol=size(zernFeats,2)/2; zernNames={};
for i=1:numZernikePol
    num=num2str(i);
    zernNames=[zernNames, ['ZernPol' num '_A'], ['ZernPol' num '_Phi']];
end
harNames={'AngularSecondMoment','Contrast','Correlation',...
    'Variance','Homogeneity','SumAverage','SumVariance','SumEntropy',...
    'Entropy','DifferenceVariance','DifferenceEntropy','InfoMeasureCorrI',...
    'InfoMeasureCorrII','MaxCorrCoeff'};
description_nucFeat=[{'Area','Eccentricity','RatioAxes','MedianRed','EntropyRed',...
    'MinIntensity','MaxIntensity','EquivDiameter','Orientation',...
    'EntropyIntensity','MedianIntensity','EdgeMeanIntensity','RatioMedianRedBlue',...
    'RatioMedianRedGreen'},harNames,zernNames];
description_denTIL ={'#Lymp/TissueArea','LympTotalArea/TissueArea',...
        '#Lymp/#TotalNuclei','MaxLympGroupingFactor','MinLympGroupingFactor',...
        'AvgLympGroupingFactor','StdLympGroupingFactor',...
        'MedianLympGroupingFactor','ModeLympGroupingFactor','NumHighlyGroupedLymp',...
        '#Lymp/TotalConvHullArea','LympConvHullArea/TotalConvHullArea',...
        'IntersectedAreaConvHullLymp&NonLymp','MaxDensityMatrixVal',...
        'MinDensityMatrixVal','AvgDensityMatrixVal','StdDensityMatrixVal',...
        'MedianDensityMatrixVal','ModeDensityMatrixVal',...       
        };
description_ctxTIL = {'filtquantvarmatK1','filtquantvarmatK2','filtquantvarmatK3','filtareasvarmatK1',...
    'filtareasvarmatK2','filtareasvarmatK3','filtareasmeanmatK1','filtareasmeanmatK2','filtareasmeanmatK3',...
    'filtareasmedianmatK1','filtareasmedianmatK2','filtareasmedianmatK3','filtareasstdmatK1','filtareasstdmatK2',...
    'filtareasstdmatK3','filteccentricityvarmatK1','filteccentricityvarmatK2','filteccentricityvarmatK3',...
    'filteccentricitymeanmatK1','filteccentricitymeanmatK2','filteccentricitymeanmatK3','filteccentricitymedianmatK1',...
    'filteccentricitymedianmatK2','filteccentricitymedianmatK3','filteccentricitystdmatK1','filteccentricitystdmatK2',...
    'filteccentricitystdmatK3','filtdiametervarmatK1','filtdiametervarmatK2','filtdiametervarmatK3',...
    'filtdiametermeanmatK1','filtdiametermeanmatK2','filtdiametermeanmatK3','filtdiametermedianmatK1',...
    'filtdiametermedianmatK2','filtdiametermedianmatK3','filtdiameterstdmatK1','filtdiameterstdmatK2',...
    'filtdiameterstdmatK3','filtmeanIntensityvarmatK1','filtmeanIntensityvarmatK2','filtmeanIntensityvarmatK3',...
    'filtmeanIntensitymeanmatK1','filtmeanIntensitymeanmatK2','filtmeanIntensitymeanmatK3',...
    'filtmeanIntensitymedianmatK1','filtmeanIntensitymedianmatK2','filtmeanIntensitymedianmatK3',...
    'filtmeanIntensitystdmatK1','filtmeanIntensitystdmatK2','filtmeanIntensitystdmatK3','filtentropyRedvarmatK1',...
    'filtentropyRedvarmatK2','filtentropyRedvarmatK3','filtentropyRedmeanmatK1','filtentropyRedmeanmatK2',...
    'filtentropyRedmeanmatK3','filtentropyRedmedianmatK1','filtentropyRedmedianmatK2','filtentropyRedmedianmatK3',...
    'filtentropyRedstdmatK1','filtentropyRedstdmatK2','filtentropyRedstdmatK3','filtratioRedBbluevarmatK1',...
    'filtratioRedBbluevarmatK2','filtratioRedBbluevarmatK3','filtratioRedBbluemeanmatK1','filtratioRedBbluemeanmatK2',...
    'filtratioRedBbluemeanmatK3','filtratioRedBbluemedianmatK1','filtratioRedBbluemedianmatK2',...
    'filtratioRedBbluemedianmatK3','filtratioRedBbluestdmatK1','filtratioRedBbluestdmatK2','filtratioRedBbluestdmatK3',...
    'filtratioRedGreenvarmatK1','filtratioRedGreenvarmatK2','filtratioRedGreenvarmatK3','filtratioRedGreenmeanmatK1',...
    'filtratioRedGreenmeanmatK2','filtratioRedGreenmeanmatK3','filtratioRedGreenmedianmatK1',...
    'filtratioRedGreenmedianmatK2','filtratioRedGreenmedianmatK3','filtratioRedGreenstdmat','filtratioRedGreenstdma2',...
    'filtratioRedGreenstdma3'};
save([folder_savepath 'histoTIL_feature_description.mat'],'description_nucFeat','description_denTIL','description_spaTIL','description_ctxTIL');
end